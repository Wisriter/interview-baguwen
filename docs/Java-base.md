# 访问修饰符控制范围

答：

1. 公开级别：	用public 修饰，对外公开
2. 受保护级别：用protected修饰，对子类和同一个包中的类公开
3. 默认级别：没有修饰符号，向同一个包的类公开.
4. 私有级别：用private修饰,只有类本身可以访问，不对外公开.



# 面向对象的特点

答：面向对象编程（Object-Oriented Programming，OOP）是一种编程范式，它使用“对象”来表示数据和方法，将数据和处理数据的方法封装在一起。Java 是一种面向对象的编程语言，它支持面向对象编程的所有基本概念。面向对象编程有以下几个主要特性：

1. **封装（Encapsulation）**：将 方法 和 属性 写到同一个类中，并将属性 私有化，生成 get set方法，外部访问属性需要通过get和set方法,内部可以直接访问属性，这样的一个类我们认为它完成了封装。
2. **继承（Inheritance）**：继承是一种机制，允许一个类（子类）继承另一个类（父类或超类）除private修饰的所有属性和方法。子类可以重写父类的方法，也可以添加新的方法。Java 不支持多重继承，但可以通过接口实现类似的功能。
3. **多态（Polymorphism）**：在 Java 中，多态性主要有两种形式：方法重写（子类重写父类的方法）和方法重载（同一个类中定义多个同名方法，参数列表不同）。
4. **抽象（Abstraction）**：在 Java 中，可以通过接口和抽象类来实现抽象。接口定义了一组方法，但不提供实现，而抽象类可以提供部分实现。
5. **接口（Interface）**：接口是一种完全抽象的类，它只包含方法的签名，没有方法的实现。接口用于定义一个类必须遵循的协议或行为规范。
6. **动态绑定（Dynamic Binding）**：在运行时根据对象的实际类型来调用相应的方法，这是多态的实现机制之一。
7. **垃圾回收（Garbage Collection）**：Java 有自动内存管理机制，可以自动回收不再使用的对象，减少内存泄漏的风险。



# 面向对象和面向过程

【https://www.zhihu.com/question/27468564/answer/757537214】（通俗易懂）

1. 面向对象：应对新需求时，无需更改已经测试通过的既有的类，只需要写新的类或者子类即可。具有良好的灵活性和扩展性，假若某天不再需要时，将对应的类删除即可。
2. 面向过程：把任务分解成一系列步骤去实现。当需求变得越来越复杂时，实现起来会比较困难。不够灵活。复用性不佳：按过程来的话，不同过程中相似的代码也不好进行复用，前半段的过程中用到的逻辑，在后半段再次使用的话需要再写一遍，如果是相同的逻辑，修改也会出现很多复杂问题。拓展性不易：举个例子，相同的逻辑，如果要有两份相似逻辑，那在面向过程中，就很多时候需要写两份。耦合度高：有一个比喻很合适，说面向过程是蛋炒饭，面向对象是盖浇饭，即，面向过程很难将内容剥离开，都混在了一起，要改一个东西，往往会改全文；而面向对象改的时候就改得比较少。



# 抽象类和接口有什么不同？

【https://baijiahao.baidu.com/s?id=1675962405769465694&wfr=spider&for=pc】

<img src="https://cdn.nlark.com/yuque/0/2024/png/26317314/1716392069843-1bcce7de-f38b-445b-8ed3-b0432f5f5ab8.png" alt="img" style="zoom: 67%;" />

答：**抽象类的特点：**

1、使用abstract关键字，抽象类不能被实例化，即不能使用new关键字来实例化对象，只能被继承；

2、包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；

3、抽象类中的抽象方法的修饰符只能为public或者protected，默认为public；

4、抽象类中的抽象方法只有方法体，没有具体实现；

5、如果一个子类实现了父类（抽象类）的所有抽象方法，那么该子类可以不必是抽象类，否则就是抽象类；

6、抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。

**抽象类和普通类的主要有三点区别：**

1、抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。

2、抽象类不能用来创建对象；

3、如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。

在其他方面，抽象类和普通的类并没有区别。

**接口的特点：**

接口使用interface关键字修饰。接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。接口只是一种形式，接口自身不能做任何事情。

接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（**并且只能是public static final变量**，用private修饰会报编译错误），**而方法会被隐式地指定为public abstract方法****且只能是public abstract方法**（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。

要让一个类遵循某组特地的接口需要使用implements关键字。

**抽象类和接口的应用场景**

1、如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类。

2、如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。

3、如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。



# 继承和抽象的区别？

答：

**抽象**

1. **抽象类**：使用 abstract 关键字声明，不能被实例化。
2. **抽象方法**：没有方法体，只有声明，也使用 abstract 关键字。
3. **具体方法**：可以有方法体，提供了部分实现。
4. **目的**：定义接口或部分实现，允许不同的子类以自己的方式实现相同的接口。如一个shape类中定义一个计算面积的抽象方法。
5. **使用场景**：当你希望定义一个通用的接口，而具体的实现将由派生类提供时。

**继承**

1. **基类（父类）**：提供了一些基本的属性和方法，可以被实例化。
2. **派生类（子类）**：继承自基类，使用 extends 关键字。
3. **重写（Override）**：子类可以重写父类的方法，以提供特定的实现。
4. **目的**：允许创建一个新的类，它是现有类的修改版或扩展。
5. **使用场景**：当你希望创建一个新类，且这个新类是现有类的特殊版本时。



# 重载和重写

可变长参数

lambda表达式：Java 8引入的一个新特性，用于简化代码的编写，特别是在使用函数式接口时。基本语法：`(parameter1, parameter2, ...) -> expression`

Object.clone()是浅拷贝

Error和Exception的父类是Throwable

全局异常处理：可以使用AOP，可以定义一个切面来拦截所有可能抛出异常的方法，并在切面中处理这些异常。



# 讲一讲java的反射？

答：反射是指根据类的类对象来创建类实例，并调用实例方法。

1. **获取 Class 类对象有三种方法**

**第一种，使用 Class.forName 静态方法。**当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。有时候，我们需要根据配置文件的信息（比如类的全路径）创建类的实例并调用方法，而不是在代码里面直接new一个对象，那么此时我们就需要根据类的全路径创建对象并调用方法，这也是反射的一种方式。

```vbnet
Class clz = Class.forName("java.lang.String");
```

<img src="https://cdn.nlark.com/yuque/0/2024/png/26317314/1714643397827-a13eca1b-0665-4b61-99ad-b3ddc5afecda.png" alt="img" style="zoom: 80%;" />

但是，直接使用Class类对象的newInstance()方法已经被启用（虽然抛个异常代码还是可以运行），因此推荐构造器+构造器.newInstance的方法：

```vbnet
Constructor<?> constructor = clazz.getDeclaredConstructor();  
constructor.setAccessible(true); // 如果构造函数不是public的，需要设置为可访问  
Object instance = constructor.newInstance();
```

**第二种，使用 .class 方法。**

这种方法只适合在编译前就知道操作的 Class。

```vbnet
Class clz = String.class;
```

**第三种，使用类对象的 getClass() 方法。**

```vbnet
String str = new String("Hello");
Class clz = str.getClass();
```



2. **得到类的Class类对象（注意：Class类对象的类为java.lang.Class）之后，如何创建实例并调用方法呢？**

通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法（已启用）、通过 Constructor 对象的 newInstance() 方法

而方法的调用如下

```
Method method1 = cls.getMethod("Eat");//方法的名字
method1.invoke(o);//执行方法
```

