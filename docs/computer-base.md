# 计网

## OSI 7层模型



| **名称**       | **功能**                                         | **传输单位**               | **协议**                             | **服务访问点** | **设备**       |
| -------------- | ------------------------------------------------ | -------------------------- | ------------------------------------ | -------------- | -------------- |
| **应用层**     | 用户与网络的界面                                 |                            | HTTP、SMTP、FTP、DNS                 | 用户界面       |                |
| **表示层**     | 数据格式转换，数据压缩，加密，解密               |                            |                                      |                |                |
| **会话层**     | 进程间会话的建立、管理和终止                     |                            |                                      |                |                |
| **传输层**     | 端到端的通信，主机中两个进程之间                 | 报文(TCP)、用户数据报(UDP) | TCP、UDP                             |                |                |
| **网络层**     | 差错控制、流量控制、拥塞控制、网际互联           | 分组或数据报               | IP、IPX、ICMP、IGMP、ARP、RARP、OSPF | IP地址         | 路由器         |
| **数据链路层** | 点到点的通信。成帧、差错控制、流量控制、传输管理 | 帧                         | SDLC、HDLC、PPP、STP                 | MAC地址        | 交换机         |
| **物理层**     | 透明传输比特流                                   | 比特                       |                                      | 网卡接口       | 中继器、集线器 |



## TCP/IP 5层是哪五层?

答：TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：

1. 应用层
2. 传输层
3. 网络层
4. 网络接口层（数据链路层，物理层）

具体地，**应用层**主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层**传输层**来传输。 应用层交互的数据单元称为报文。

其中，应用层工作在操作系统中的用户态，传输层及以下则工作在内核态



## TCP和UDP的区别

答：**在****TCP / IP网络分层模型中，传输层有两个协议，TCP和UDP。**TCP（Transmission Control Protocol，传输控制协议 ）：提供 面向连接 的，可靠 的数据传输服务。UDP（User Datagram Protocol，用户数据协议）：提供 无连接 的，尽最大努力 的数据传输服务（不保证数据传输的可靠性），简单高效。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。

***



## HTTP/HTTPS的区别

## 答：这是应用层的协议，HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。SSL/TLS使用非对称加密对**对称秘钥**进行加密（非对称加密：发送者用接收者的公钥加密报文，接收者用自己的私钥进行解密。对称加密：加密的密钥和解密的密钥相同。也就是说使用非对称加密对对称秘钥本身进行加密，保证安全性。而对消息使用对称加密）
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

***



## HTTPS加密过程

答：https也会同http一样进行三次握手，但是它还会进行一个加密协议的握手过程，这个加密协议的过程如下

1）服务器向客服端颁发数字证书，在证书里面包含有公钥（用于加密），服务器自己保留私钥（私钥用于解密）

2）当客户端收到这个证书后，就会解析这个证书，看里面的公钥是否有效，如果没有什么问题的话就会生成一个随机值

3）然后客户端会对这个随机值用公钥进行加密，然后发给服务器。这样做的目的就是为了让服务器得到这个随机值，以后客服端和服务端都可以用这个随机值进行加密解密

4）服务器收到这个随机值后，就用它自己的私钥对这个随机值进行解密。然后服务器再把要传输的信息和这个随机值通过算法混合在一起，然后发给客户端。这样的话，除非知道这个随机值，不然是无法知道服务器传输的信息的。

5）客户端收到以后，再用之前生成的随机值，进行解密，然后就可以得到服务器传过来的信息。

![img](https://cdn.nlark.com/yuque/0/2024/png/26317314/1716377544525-43b67ec8-2a92-48d0-ad85-1fbe911f9f68.png)



## HTTP2, QUIC, HTTP3

HTTP/2.0了解吗？你了解过QUIC协议吗？有什么好处？为什么HTTP/3.0要使用UDP呢？

答：HTTP/2.0 是一种改进的 HTTP 协议，旨在提高网络通信的效率和性能。它基于 SPDY 协议。以下是 HTTP/2.0 的一些关键特性和好处：

1. 二进制分帧：HTTP/2.0 使用二进制分帧层，将请求和响应分解为独立的帧，这些帧可以交错发送，提高了数据传输的效率。
2. 多路复用：HTTP/2.0 允许在单一的连接上同时发送多个请求和响应，解决了 HTTP/1.x 中的队头阻塞问题，即前一个请求的处理或响应不会阻塞后续请求的处理。
3. 头部压缩：HTTP/2.0 引入了 HPACK 压缩算法，对请求和响应的头部信息进行压缩，减少了冗余头部信息的传输，从而减少了数据传输量。
4. 服务器推送：服务器可以主动向客户端推送资源，而不需要客户端明确请求，这加快了页面的加载速度。



QUIC 是一种由 Google 开发的基于 UDP 的低延迟传输协议，它旨在提供比 TCP 更快的连接建立时间和更低的延迟。QUIC 的一些好处包括：

1. **更快的连接建立**：QUIC 通过减少握手过程中的往返次数，实现了更快的连接建立。
2. **0-RTT 连接**：QUIC 允许在某些情况下进行 0-RTT 连接建立，这意味着客户端可以在没有等待服务器响应的情况下发送数据2。
3. **连接迁移**：QUIC 使用一个独特的连接 ID 而不是四元组（IP 地址和端口），允许连接在不同网络间迁移而不会中断。
4. **改进的拥塞控制**：QUIC 可以在应用层实现不同的拥塞控制算法，而不需要修改操作系统和内核。
5. **多路复用和无队头阻塞**：与 HTTP/2.0 类似，QUIC 也支持多路复用，但没有 TCP 的队头阻塞问题，因为 QUIC 是基于 UDP 的。



HTTP/3.0，也称为 HTTP-over-QUIC，选择使用 UDP 而不是 TCP 的原因包括：

1. **减少连接建立时间**：UDP 的连接建立时间比 TCP 快，因为不需要经过三次握手过程，这有助于减少延迟。
2. **避免队头阻塞**：UDP 不保证数据包的顺序，因此 QUIC 可以在 UDP 上实现无队头阻塞的多路复用。
3. **连接迁移**：UDP 的无状态特性使得 QUIC 能够更容易地处理网络切换和连接迁移。
4. **更好的拥塞控制**：QUIC 可以在应用层实现更先进的拥塞控制算法，而不受操作系统内核的限制。
5. **安全性**：QUIC 从一开始就设计为与 TLS 集成，提供了更好的安全性和加密功能。

总的来说，HTTP/3.0（基于 QUIC）旨在结合 HTTP/2.0 的特性和 UDP 的效率，以提供更快、更安全、更可靠的网络通信。



## 在浏览器里输入一个HTTP的URL地址之后显示页面，其中的流程如何

答：简单来说包含5步：①域名解析，②建立(tcp)连接，③客户端发送（http）请求，④服务器处理请求并响应，⑤浏览器解析和页面渲染：

1. **解析URL**：

- - 浏览器首先解析URL以确定要访问的资源的位置。**DNS解析**：

- - 如果浏览器尚未缓存目标服务器的IP地址，则需要通过DNS（域名系统）解析域名以获取其IP地址。

1. **建立连接**：

- - 浏览器使用解析得到的IP地址，通过TCP（传输控制协议）与服务器建立连接。这通常涉及一个称为“三次握手”的过程。

1. **发送HTTP请求**：

- - 一旦TCP连接建立，浏览器就会构造一个HTTP（超文本传输协议）请求消息，并通过TCP连接发送给服务器。

1. **服务器处理请求**：

- - 服务器接收到HTTP请求后，会根据请求的类型（如GET、POST等）和请求的资源路径处理请求。

- - 服务器处理完请求后，会构造一个HTTP响应消息，将所请求的内容（如HTML文档）作为响应体发送回浏览器。

1. **关闭TCP连接**：

- - 在HTTP/1.0中，默认每个请求/响应后都会关闭TCP连接。HTTP/1.1引入了持久连接，可以在一个TCP连接上发送多个HTTP请求和响应，减少了建立和关闭连接的开销。

1. **浏览器渲染页面**：

- - 浏览器开始接收来自服务器的响应数据：

- - - 首先，浏览器检查HTTP响应状态码，以确定请求是否成功（如状态码200表示成功）。
    - 浏览器解析响应体中的HTML文档，构建DOM（文档对象模型）树。
    - 浏览器发送额外的HTTP请求以获取HTML文档中引用的资源，如CSS样式表、JavaScript文件和图片。

1. **页面渲染**：

- - 浏览器使用CSS样式和JavaScript进一步处理页面，并将解析的HTML和CSS合并成渲染树。
  - 浏览器进行布局（layout）处理，计算出每个元素在页面上的确切位置。
  - 最后，浏览器使用渲染树和布局信息绘制（painting）页面，用户就可以看到完整的网页内容。

整个流程涉及到网络通信、服务器处理、浏览器解析和渲染等多个环节，每个环节都可能对页面加载时间产生影响。开发者和用户可以通过各种方法优化这个过程，比如使用CDN、压缩资源、利用浏览器缓存等。



## TCP为什么一定要有三次握手

答：通过使用三次握手（Three-way Handshake）来建立一个可靠的连接，这是为了确保双方都准备好进行数据传输。三次握手的步骤如下：

1. **SYN**：客户端发送一个带有SYN（Synchronize Sequence Numbers，同步序列编号）标志的TCP段到服务器以初始化一个连接。这个SYN段中包含客户端的初始序列号（seq=x）（Sequence Number, seq），表示客户端准备好发送数据。（读作sin包）
2. **SYN-ACK**：服务器收到这个SYN段后，如果同意建立连接，则会发送一个TCP段作为响应。这个响应包含服务器的初始序列号（seq=y）和确认号（ack=x+1），确认号是客户端的序列号加一。同时，服务器的SYN标志和ACK标志都被设置。
3. **ACK**：客户端收到服务器的SYN-ACK响应后，会发送一个确认段（ACK）给服务器，其中包含确认号（ack=y+1），表明客户端已经准备好接收数据。此时，连接建立成功。



## TCP四次挥手经历的状态

答：

1. **第一次挥手**：客户端发送一个 FIN（SEQ=x） 标志（Finish）的数据包->服务端，用来关闭客户端到服务器的数据传送。然后客户端进入 **FIN-WAIT-1** 状态。
2. **第二次挥手**：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后服务端进入 **CLOSE-WAIT** 状态，客户端进入 **FIN-WAIT-2** 状态。
3. **第三次挥手**：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 **LAST-ACK** 状态。
4. **第四次挥手**：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入**TIME-WAIT**状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 **CLOSE** 状态。此时如果客户端等待 **2MSL** (Maximum Segment Lifetime，报文段最长寿命)后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。

<img src="https://cdn.nlark.com/yuque/0/2024/png/26317314/1713754242056-8c981c12-eddc-460f-b2a5-555fd2091500.png" alt="img" style="zoom:67%;" />

## 为什么是四次挥手，而不是三次？

答：关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。



## cookie、session和token

答：因为http 协议是无状态的。所以需要cookie-session或token证明身份。session在服务器中存储，占用一定的空间，根据session id找到对应的session。token轻量，只要可以正确进行jwt解析，就能证明身份。

1. 在登录成功之后，服务器端会给浏览器颁发 cookie 。下次访问的时候，带上 cookie ，服务器就认识你了。cookie 的结构：**cookie = Name + Value + （有效期、安全性、使用范围）。**可以通过key为session_id，查看具体的id值。

![img](https://cdn.nlark.com/yuque/0/2024/png/26317314/1716955479764-8cc84396-d6dc-4257-99e3-a3631345a5f9.png)

1. token（令牌）可以存储在多个地方，包括cookie、sessionStorage和localStorage。
2. 在HTML5之前，开发人员一般是通过使用Cookie在客户端保存一些简单的信息。在HTML5发布后，提供了一种新的客户端本地保存数据的方法，那就是Web Storage，它也被分为：LocalStorage和SessionStorage，它允许通过JavaScript在Web浏览器中以键值对的形式保存数据。Web Storage拥有更大的存储容量，Cookie是4k，Web Storage为5M。



http cookie干什么？如何在http传递？关掉浏览器cookie是否消失？cookie欺骗？

答：HTTP Cookie 用于：

1. **会话管理**：通过识别用户的会话，Cookie 允许服务器跟踪用户的活动，例如在电子商务网站中的购物车信息。
2. **个性化**：Cookie 可以存储用户的偏好设置，如语言选择、主题或其他自定义选项。
3. **认证**：网站可以使用 Cookie 来识别已登录的用户，减少重复输入用户名和密码的需要。
4. **追踪**：网站可以使用 Cookie 来追踪用户的行为，包括他们访问的页面和点击的链接，以进行数据分析和用户行为研究。

Cookie 如何HTTP 中传递：

- 当用户访问一个网站时，服务器可以在 HTTP 响应中通过 Set-Cookie 首部设置 Cookie。
- 浏览器接收到 Cookie 后，会在本地存储，并在之后的请求中自动通过 Cookie 请求首部将 Cookie 发送回服务器。

关闭浏览器后 Cookie 是否消失：

- 这取决于 Cookie 的类型。**会话 Cookie**（Session Cookie）在用户关闭浏览器时通常会自动消失。
- **持久 Cookie**（Persistent Cookie）设置了一个过期时间，即使关闭浏览器，它们也会保留，直到达到过期时间或用户手动清除。

关于 Cookie 欺骗：

- Cookie 欺骗通常指的是一种攻击者尝试窃取或篡改用户 Cookie 的行为，这可能通过 XSS（跨站脚本攻击）或 CSRF（跨站请求伪造）等手段实现。
- 为了提高安全性，网站可以使用 HTTPS 来加密 Cookie，防止中间人攻击。
- 设置 HttpOnly 属性可以防止 JavaScript 访问 Cookie，减少 XSS 攻击的风险。



## 讲一下Socket编程

答：Socket编程是一种网络编程技术，用于在网络中的不同计算机之间实现数据通信。它基于套接字（socket）的概念，套接字是网络通信的端点，可以看作是一种抽象的通信通道。

1. **套接字（Socket）**：网络通信的端点，是进程间通信的抽象层。
2. **TCP和UDP**：Socket支持的主要协议，TCP提供可靠的连接，UDP提供快速但不保证可靠性的连接。
3. **端口号和IP地址**：用于唯一标识网络中的服务和设备。
4. **服务器和客户端**：

- - 服务器监听特定端口，等待连接。
  - 客户端请求连接服务器。

1. **三次握手**：TCP连接的建立过程。
2. **数据传输**：通过已建立的连接进行数据的发送和接收。
3. **关闭连接**：通过四次挥手过程释放TCP连接。
4. **套接字API**：提供创建套接字、绑定、监听、连接、数据传输等操作的函数。

Socket编程是实现网络通信的核心，广泛应用于各种网络应用和服务。

***



# 操作系统

## 进程线程区别？

答：

1. 进程是资源分配的单位；
2. 线程是CPU调度的单位；
3. 协程是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）

线程与进程的区别:

\1) 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间

\2) 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源

\3) 线程是处理器调度的基本单位,但进程不是

\4) 二者均可并发执行

\5) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制

**协程：**协程（Coroutine）是一种程序组件，用于程序的并发执行。与多线程相比，协程是轻量级的，它们的创建、销毁和切换的开销都远小于线程。协程的主要特点是可以在任意位置挂起和恢复执行，非常适合处理I/O密集型任务，因为它们可以在等待I/O操作完成时挂起，从而让出CPU给其他协程使用。



## 内核态和用户态

答：操作系统，将内存分成了两个区域：内核空间（Kernal Space），这个空间只有内核程序可以访问；用户空间（User Space），这部分内存专门给应用程序使用。

用户态和内核态：用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在用户态（User Mode） 执行。内核空间中的代码可以访问所有内存，我们称这些程序在内核态（Kernal Mode） 执行。当一个进程执行**系统调用**时，就会进入内核态。



**PCB进程控制块**

答：在操作系统中，是用进程控制块（process control block，PCB）数据结构来描述进程的。PCB 是进程存在的唯一标识。PCB包括描述进程和控制进程的全部信息。包括



## **进程的几个状态**

答：创建，就绪，运行，阻塞，结束。挂起是指放到外存（硬盘里面）

<img src="https://cdn.nlark.com/yuque/0/2024/jpeg/26317314/1716111973183-63549380-6f39-469b-ab7b-790a7569e668.jpeg?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_955%2Climit_0%2Finterlace%2C1" alt="img" style="zoom:80%;" />

***



## 并发和并行？

答：并发和并行的区别就在于**同时**二字。

虽然并发和并行都能运行多个程序，但区别就在于：

- 并发是多个程序交替运行，因为时间片很短，用户并不会感觉到

- - 时间片的分配标准也是以可感知程度设计的，Linux 的时间片范围为 5ms ~ 800ms

- 并行是多个程序同时运行

***



## 死锁条件？

答：死锁是指由于资源分配不当或进程运行顺序不合理，导致一组进程都在等待其他进程释放资源而无法继续执行的一种状态。发生的四个基本条件是：

1. **互斥**：每个资源要么已经被一个进程占有，要么就是空闲的。在任意时刻，如果资源已经被一个进程占有，那么其他进程就不能再占有这个资源。
2. **占有和等待**：至少有一个进程持有一个资源，并且等待获取其他进程持有的资源。
3. **不可抢占**：资源只能由占有它的进程自愿释放。
4. **循环等待**：存在一个进程序列，其中每个进程都在等待下一个进程所占有的资源。

避免死锁通常需要破坏这四个条件中的至少一个。

***



## LRU算法

答：【https://skyhigh233.com/blog/2016/10/07/lru-cache/】

LRU是Least Recently Used 近期最少使用算法。 内存管理的一种页面置换算法，对于在内存中但又不用的数据块（内存块）叫做LRU，操作系统会根据哪些数据属于LRU而将其移出内存而腾出空间来加载另外的数据。虚拟页式存储管理，是将进程所需空间划分为多个页面，内存中只存放当前所需页面，其余页面放入外存的管理方式。LRU算法如下：

假设 序列为 4 3 4 2 3 1 4 2

物理块有3个 则

首轮 4调入内存 4

次轮 3调入内存 3 4

之后 4调入内存 4 3

之后 2调入内存 2 4 3

之后 3调入内存 3 2 4

之后 1调入内存 1 3 2（因为最少使用的是4，所以丢弃4）

之后 4调入内存 4 1 3（原理同上）

最后 2调入内存 2 4 1

规律就是，如果新存入或者访问一个值，则将这个值放在队列开头。如果存储容量超过上限cap，那么删除队尾元素，再存入新的值。

LFU算法（Least Frequently Used）：根据数据的访问频率来淘汰数据。例如缓存容量为3，有ABC三个数据块，访问次数分别为123，现在需要访问D数据块，那么就需要替换掉A数据块。特殊地，当数据块访问次数一样时，替换掉最近未被使用的，或采用其他方法。

***

