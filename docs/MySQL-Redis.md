# MySQL

## MySQL事务

<img src="https://cdn.nlark.com/yuque/0/2024/jpeg/26317314/1716364601277-cc800cfa-e425-420f-936c-6865dfbe728c.jpeg" alt="img" style="zoom:50%;" />

答：思维导图如上。

【https://blog.csdn.net/weixin_46784756/article/details/136279973】

事务的特性

1. 原子性：一组事务内的多个操作，要么全部执行成功，要么全部执行失败。由undo log日志来实现。
2. 一致性：一组事务内数据的变化是一致的，比如A向B转账300元，A账户减少300的同时B账户一定是增加300。由其他三个特性共同支撑。
3. 隔离性：一组事务内执行的操作，不能受到其他事务的干扰否则会导致（脏读、脏写、幻读、不可重复读）问题。由各种锁以及MVCC版本机制来实现。
4. 持久性：一组事务内的操作执行完以后一定是要保存到磁盘的，不能事务完成以后数据没有被持久化。由redo log日志来实现。

**2.1 并发事务带来的问题**

多个事务同时对一条数据进行操作时可能会出现脏写、脏读、幻读、不可重复读问题：

1. **脏写：**事务内更新一条记录后被其他事务更新覆盖。脏写通常不是一个被讨论的概念，因为在大多数数据库系统中，一个事务不可能直接修改另一个未提交事务的修改
2. **脏读：**事务内读到了其他事务没有提交的数据。
3. **不可重复读：**与幻读类似，但是特指**修改**，事务内两次相同的sql执行结果不一致，读取到了其他事务提交的修改数据。
4. **幻读：**特指**新增或删除**，事务内两次相同sql执行的结果不一致，读取到了其他事务提交的新增或删除数据。



## 隔离级别

隔离级别主要用来解决脏读（Dirty Read）、不可重复读（Non-repeatable Read）和幻读（Phantom Read）等问题。四种隔离级别（从低到高）：

1. **读-未提交（Read Uncommitted）**

- - 这是最低的隔离级别。
  - 一个事务可以读取另一个未提交事务的数据。
  - 可能产生脏读、不可重复读和幻读。

1. **读-已提交（Read Committed）**

- - 大多数数据库系统的默认隔离级别（但不是 MySQL 的默认级别）。
  - 一个事务只能读取另一个已提交事务的数据。
  - 可以避免脏读，但可能出现不可重复读和幻读。

1. **可重复读（Repeatable Read）**

- - 这是 MySQL 的默认隔离级别（在 InnoDB 存储引擎中）。
  - 对同一字段的多次读取结果都是一致的。
  - 可以避免脏读和不可重复读，但可能出现幻读（在某些情况下，InnoDB 可以通过多版本并发控制（MVCC）来避免幻读）。

1. **串行化（Serializable）**

- - 最高的隔离级别。
  - 所有的事务依次逐个执行，这样事务之间就不可能产生干扰。
  - 可以避免脏读、不可重复读和幻读。
  - 但这种方式的性能开销最大，因为事务只能一个接一个地执行。

![img](https://cdn.nlark.com/yuque/0/2024/png/26317314/1716366250942-343e1b19-a8da-45e3-9d90-06926b7e9829.png)



## 锁和MVCC

在并发环境下。事务隔离级别可以通过锁（Locking）和多版本并发控制（MVCC, Multiversion Concurrency Control）这两种主要机制来实现。以下是关于这两种机制如何影响事务隔离级别的解释：

**锁（Locking）**

**锁与事务隔离级别**：

- 不同的隔离级别决定了何时以及如何加锁。例如，在“读未提交”级别，读操作不会加锁，因此可以读取到其他未提交事务的修改（脏读）。而在“读已提交”或更高的级别，**读操作可能会加共享锁**，以阻止其他事务同时修改数据。
- **写入操作通常会加排他锁**，以防止其他事务读取或修改被锁定的数据。
- 共享锁通常用于表级锁，而排他锁则用于行级锁

**锁的类型**：

- **全局锁**：锁定数据库中的所有表，使得整个数据库实例处于只读状态。
- **表级锁**：每次操作锁住整张表，粒度较大但开销较小。
- **行级锁**：每次操作锁住对应的行数据，粒度最小但开销最大。

**多版本并发控制（MVCC）**

**MVCC的概念**：

- MVCC是通过数据行的多个版本管理来实现数据库的并发控制。每个事务在开始时都会看到一个一致性的数据库快照，并且在这个事务执行期间，其他事务的修改是不可见的。

**MVCC与事务隔离级别**：

- MVCC主要用于支持“可重复读”和更高的隔离级别。通过为每个事务提供数据的一个快照，MVCC确保了即使在有其他事务并发修改数据的情况下，该事务也能看到一致的数据视图。

**MVCC的工作原理**：

- MVCC为每个读写操作创建多个版本的数据。每个事务都有一个与之关联的时间戳或版本号。
- 当事务进行读操作时，它只会读取在其开始时间之前提交的数据版本。
- 当事务进行写操作时，它会在内存中创建一个新的数据版本，并在事务提交时将其标记为可见。

**MVCC的优势**：

- 提高了数据库的并发性能，因为读操作不需要等待写操作完成，而写操作也不需要等待读操作完成。
- 解决了脏读、不可重复读和幻读等问题。

总的来说，锁和MVCC是两种实现事务隔离级别的主要机制。它们各自有其优缺点和适用场景，数据库管理系统通常会根据具体的隔离级别和性能需求来选择使用哪种机制或同时使用两种机制。



## MySQL死锁：原因、示例、解决方案

答：

1)**表的死锁**产生原因:

用户A访问表A(锁住了表A)，然后又访问表B;另一个用户B访问表B(锁住了表B)，然后企图访问表A;这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。

用户A--》A表(表锁)--》B表(表锁)

用户B--》B表(表锁)--》A表(表锁)

**解决方案:**

这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。

仔细分析程序的逻辑，**对于数据库的多表操作时，尽量按照相同的顺序进行处理**，尽量避免同时锁定两个资源，如操作A和B两张表时，总是按先A后B的顺序处理，必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。



## 数据库有哪些优化查询性能的方法？

答：

1. **使用索引**：为经常查询的列创建索引，尤其是WHERE子句中使用的列，以加快数据检索速度。
2. **优化查询语句**：避免使用SELECT *，只选择需要的列；减少子查询和复杂的JOIN操作，尽量使用等值连接。
3. **避免全表扫描**：通过合理设计索引避免全表扫描，如果需要进行全表扫描，考虑是否可以通过分表来优化。
4. **使用查询缓存**：对于频繁执行且结果集不变的查询，可以使用查询缓存来提高性能。
5. **优化数据类型**：为列选择合适的数据类型，以减少存储需求和提高查询性能。
6. **减少多表查询**：尽量减少多表联查，可以考虑使用物化视图或临时表来预先计算多表查询的结果。
7. **定期维护数据库**：更新统计信息、重建索引和清理碎片，以保持数据库性能。
8. **监控和分析**：使用数据库监控工具分析慢查询，找出性能瓶颈并进行优化。
9. **合理使用事务**：避免长时间运行的事务，合理控制事务大小，以减少锁争用和提高并发性能。
10. **优化存储引擎**：根据应用场景选择合适的存储引擎，比如InnoDB用于事务处理，MyISAM用于只读或轻度更新的表。



## mysql索引使用的注意事项

答：常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。

优点：使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 减少 IO 次数，这也是创建索引的最主要的原因。通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

缺点：创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。索引需要使用物理文件存储，也会耗费一定空间。

大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。

索引类型：主键索引，unique索引，普通索引，全文索引。如果某列的值，是不会重复的，则优先考虑使用 unique 索引, 否则使用普通索引

1. 较频繁的作为查询条件字段应该创建索引select * from emp where empno =1
2. 唯一性太差的字段不适合单独创建索引,即使频繁作为查询条件select* from emp where sex ="男‘
3. 更新非常频繁的字段不适合创建索引
4. 不会出现在WHERE子句中字段不该创建索引

**B+树索引：**B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个**双向链表**。（图里面画错了，是双向链表）

<img src="https://cdn.nlark.com/yuque/0/2024/png/26317314/1713709543467-2fe841e5-a4cd-4a76-9a0d-5e6a092953a4.png" alt="img" style="zoom: 67%;" />



## MySQL索引为什么使用B+树？

答：MySQL 使用 B+ 树作为索引的数据结构，而不是其他数据结构，主要是因为 B+ 树具有以下几个优点：

1. **有序性**：B+ 树的叶子节点存储了所有数据，并且这些数据是按照键值顺序排列的，形成了一个有序链表。这使得 B+ 树非常适合执行范围查询和排序操作。
2. **平衡性**：B+ 树是一种自平衡的树结构，它可以保证**所有叶子节点都在同一层**，这有助于保持查询效率的稳定。
3. **磁盘I/O优化**：B+ 树的**内部节点不存储数据，只存储键值和指针**，这使得单个节点可以存储更多的键值，减少了树的高度，从而**减少了查找数据时所需的磁盘I/O次数**。
4. **缓存性能**：由于 B+ 树的节点可以存储更多的键值，树的高度较低，这有助于提高缓存的利用率，因为整个节点更有可能同时被加载到内存中。
5. **快速查找**：B+ 树的高度相对较低，通常只需要较少的磁盘I/O操作就可以定位到目标数据，这提高了查找操作的效率。
6. **支持联合索引**：B+ 树的结构使得它能够很好地支持多列索引（联合索引）优化查询性能。



## 为什么不要建立太多索引

答：虽然索引可以加速数据库的查询操作，但是过多的索引也会给数据库带来很大的性能上的开销和空间占用。

具体来说，**每个索引都需要独立维护一个B+树结构**。当表中插入、修改、删除数据时，都需要更新该表上的所有索引，这样会增加写操作的成本，并且如果索引数量过多时，更新索引所需的时间也会变得相应地更长。

​        此外，索引也会占用较多的**存储空间**。每个索引都要在磁盘上占用一定的空间，随着索引数量的增加，存储空间的使用情况也会相应地增加，这可能会使得MySQL运行缓慢，尤其是在内存受限的情况下。

​        综上所述，确定合适的索引数量需要**考虑具体的业务场景和数据量大小**，合理的索引数量可以大幅提高查询效率和数据访问速度，但是过多的索引反而会对系统性能造成负面影响。因此，在设计数据库时需要谨慎权衡索引的数量和类型。



## MySQL索引优化和索引失效的场景

【https://www.jb51.net/article/283474.htm】

答：以下是索引失效十种场景

- **查询类型错误**，解决办法：数据表定义type字段为varchar类型，查询必须使用相同类型

```sql
select * from player where type = 0  # 类型不对
```

- **索引列参与运算**

```sql
select * from player where height + 1 > 189 # 可能失效
select * from player where height > 189 # 改成这样
```

- **错误使用通配符**
- **未用到覆盖索引**。覆盖索引（Covering Index）指的是一个包含了查询中所有必要列的索引。使用覆盖索引可以避免回表

```sql
CREATE INDEX idx_department_salary ON employees (department, salary); # 创建一个覆盖（联合）索引
SELECT department, salary FROM employees WHERE department = 'Sales'; # 有效使用覆盖索引
SELECT name, salary FROM employees WHERE department = 'Sales'; # 未用到覆盖索引，因为name不在覆盖索引中
```

- **OR连接无索引字段**。例如type有索引，weight无索引

```sql
select * from player where type = '0' or weight = 150
# 解决办法，weight新增索引，union拼装查询数据
select * from player where type = '0'
union
select * from player where weight = 150
```

- **MySQL放弃使用索引**：MySQL发现如果使用索引性能低于全表扫描则放弃使用索引。例如在表中100万条数据height字段值全部是188，所以执行如下语句时放弃使用索引：

```sql
select * from player where height > 187
```

- **联合索引失效**

- - 索引不完整
  - 索引中断
  - **非等值匹配**。使用联合索引时，如果查询条件中存在非等值匹配（如使用 >、<、BETWEEN、LIKE '%pattern%' 等操作符），这通常会导致数据库优化器不再使用该联合索引中非等值匹配列之后的所有列。
  - 最左索引缺失。此时会进行全盘扫描

区分一下联合索引和覆盖索引：联合索引可以是覆盖索引，但并非所有联合索引都是覆盖索引。只有当联合索引中的列和查询中的 SELECT 语句中的列完全匹配时，该联合索引才是覆盖索引。而覆盖索引是强调索引是否包含了查询所需的所有字段，因此，覆盖索引可以是单列索引，也可以是联合索引。



**MySQL 事务具有四个特性：原子性、一致性、隔离性、持久性，这四个特性简称 ACID 特性**



## SQL语句

模糊查找姓王的所有学生

```sql
SELECT * FROM students WHERE last_name LIKE '王%';
```



再按照成绩进行排序，取前三个

```sql
ORDER BY score DESC
LIMIT 3;
```



## having和where的区别

答：WHERE 子句和 HAVING 子句都是 SQL 语句中的过滤条件，但它们的作用和使用场景不同：

1. **WHERE 子句**：

- - WHERE 子句用于对记录进行筛选，即在数据聚合前对行进行过滤。
  - 它可以直接作用于表中的原始数据列。
  - WHERE 子句常用于过滤掉不想要的行，只选择符合条件的数据进入下一步的数据处理。
  - 例如，在查询特定条件下的记录总数或者选择特定列的值时使用。

1. **HAVING 子句**：

- - HAVING 子句用于对聚合后的结果进行筛选，即在数据聚合后对聚合函数产生的结果进行过滤。
  - HAVING 子句通常与 GROUP BY 子句结合使用，对分组后的结果设定条件。
  - 它**不能直接作用于原始数据列，而是对** **SELECT** **语句中使用聚合函数（如** **SUM()****,** **AVG()****,** **MAX()****,** **MIN()****,** **COUNT()** **等）的结果进行过滤**。
  - 例如，在查询每个组中满足特定条件的记录数量或者特定聚合值的总和时使用。

**例子**：

假设有一个名为 sales 的表，包含 date（销售日期）和 amount（销售金额）两个字段。

使用 WHERE 子句筛选特定日期之前的所有销售记录：

```plain
SELECT * FROM sales
WHERE date < '2023-01-01';
```

使用 HAVING 子句筛选总销售额超过一定金额的组：

```plain
SELECT date, SUM(amount) AS total_sales
FROM sales
GROUP BY date
HAVING SUM(amount) > 10000;
```

在这个例子中，WHERE 子句直接作用于 sales 表中的 date 列，而 HAVING 子句则在对 amount 进行求和后，对这个聚合结果进行过滤。

**总结来说，****WHERE** **用于行记录的过滤，而** **HAVING** **用于聚合结果的过滤。**



# Redis

Redis的几种常用数据结构，以及他们的使用场景，底层实现。

答：5 种基础数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。3 种特殊数据类型：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。

1. **String（字符串）**：

- - 应用场景：存储字符串类型的数据，如缓存、计数器等。**分布式锁，商品用户信息等**
  - 底层实现：Redis中的字符串是动态字符串，底层使用了SDS（Simple Dynamic String）实现，SDS提供了O(1)时间复杂度的字符串长度获取、追加等操作。

1. **Hash（哈希）**：

- - 应用场景：存储对象，每个对象都包含键值对。在存储用户信息、缓存对象等方面应用广泛。
  - 底层实现：类似于HashMap的数据结构，可以快速定位到特定的键值对，复杂度为O(1)。

1. **List（列表）**：

- - 应用场景：存储有序的字符串列表，支持从两端进行插入、删除操作。常用于**消息队列、最新消息列表等**。
  - 底层实现：Redis的列表是使用双向链表实现的，这样可以实现高效的插入、删除操作。

1. **Set（集合）**：

- - 应用场景：存储唯一值的无序集合，支持集合间的交集、并集、差集等操作。常用于唯一值的存储和计算。**朋友圈**共同好友
  - 底层实现：基于哈希表，确保了添加、删除、查找的高效性。

1. **Sorted Set（有序集合）**：

- - 应用场景：类似于Set，但每个元素都有一个分数(score)，可以根据分数排序。常用于**排行榜**等场景。
  - 底层实现：**一个跳表（Skip List）和一个哈希表**，跳表用于保持元素有序，哈希表用于保持元素与分数的映射。跳表是以链表为基础的数据结构，通过添加多级索引来加速查找。

1. **Bitmap（位图）**：

- - 应用场景：位图存储了二进制位，支持高效的位操作，常用于标记某个状态或者计数器。例如**在线用户统计**
  - 底层实现：Redis中的位图是通过字符串实现的，但是可以对字符串的每一位进行操作。

1. **HyperLogLog（基数统计）**：

- - 应用场景：用于估计集合的基数（不重复元素的数量），常用于**统计网站UV（独立访客数）**等。
  - 底层实现：HyperLogLog是使用基于哈希的数据结构实现的，能够在较小的内存消耗下实现高效的基数估计。



## Redis为什么快？

答：主要有3个原因。

1. Redis是一个基于内存的数据存储系统。内存的访问速度比磁盘快很多。
2. Redis利用I/O多路复用和单线程执行循环来提高执行效率。
3. 高效的数据结构。查询key的时间复杂度为O(1)，并且Redis在进行数据写入操作时，会预先分配足够的空间，以减少因频繁内存分配而造成的性能损耗。（而mysql在有索引的条件下为O(log n)，没有索引则为O(n)）

I/O多路复用是一种同步I/O操作的技术，它允许同时监控多个I/O流，当有数据到达时，系统会通知程序进行相应的操作。这种方式使得Redis可以同时处理多个客户端的请求，而不需要为每个请求创建昂贵的线程或进程资源。

单线程执行循环意味着Redis的所有操作都在一个线程中顺序执行，这样可以避免多线程并发执行时的上下文切换和锁竞争开销，从而提高了执行效率。同时，这也使得Redis的代码实现更加简单，便于维护。



## 数据库和缓存如何保证一致性？

答：【小林coding】

1. 首先，无论是【先更新**缓存**再更新**数据库**】，还是【先更新**数据库**再更新**缓存**】，都存在并发问题（更新缓存——更新数据库需要一定的时间，多个线程穿插就会导致并发问题）。

<img src="https://cdn.nlark.com/yuque/0/2024/png/26317314/1713955661732-5fe99880-754a-4349-894c-ff97b27fa105.png" alt="img" style="zoom:50%;" />

解决办法是更新数据时，不更新缓存，而是删除缓存中的数据。为什么是删除而不是更新缓存，因为实际业务中，缓存的数据有的而可能不是直接来自于数据库，而是来自多张表的聚合，这个时候更新缓存可能不止一处，会很复杂。

1. 更新数据库和删除缓存的先后顺序又如何呢？可以看上面这张万能图，如果先删缓存，mysql那里还是会存在问题。而如果先更新mysql就基本不会出现什么问题。但是删除缓存会给缓存的命中率带来影响，因此，如果对命中率有要求，还是采用更新缓存的方法好一些，那么为了解决不一致的问题，可以使用锁或者给缓存一个过期时间。
2. 使用先更新数据库，再删除缓存的方案，如果操作不能同时成功依然会存在问题，为解决这个问题，可以采用重试机制或订阅MySQL binlog。

1. 1. 重试机制可以使用消息队列，把要删除的数据加入到消息队列，如果删除失败就会重试，成功了才会从队列移除。
   2. 订阅MySQL binlog 日志，拿到具体要操作的数据，然后再执行缓存删除





## 缓存穿透、缓存击穿、缓存雪崩

答：

1. **缓存穿透**： 含义：指查询一个不存在的数据，由于缓存中没有而每次都需要到数据库查询，如果大量请求查询不存在的数据，会导致数据库压力增大。 原因：数据库中不存在对应的数据，缓存中也没有，每次请求都直接到数据库查询。 解决办法：**缓存空对象，布隆过滤器**等。
2. **缓存击穿**： 含义：指一个被频繁访问的数据在缓存中过期的瞬间，大量的请求同时到达，由于缓存中无数据，导致大量请求直接访问数据库。 原因：缓存数据过期，而大量请求同时请求该数据。 解决办法：**使用互斥锁、逻辑过期或原子操作来保证缓存数据的单线程加载，设置热点数据永不过期**等。
3. **缓存雪崩**： 含义：指缓存中大量或全部数据在某一时刻同时过期，导致大量请求直接访问数据库，造成数据库压力剧增。 原因：缓存数据集中过期，大量请求同时到达。 解决办法：**缓存数据分散过期**，使用一致性哈希**减少同一时间过期的数据量**，限流，降级等。



## Redission分布式锁怎么实现的？

<img src="https://cdn.nlark.com/yuque/0/2024/png/26317314/1713707238727-b6a05b3a-f0d5-4484-a3d0-c3ed9978bea8.png" alt="img" style="zoom:80%;" />

答：Redisson是一个建立在Redis基础上的**Java驻内存数据网格**，它提供了多种分布式服务，包括分布式锁。获取锁流程如下：

1. 尝试获取锁，判断ttl （当前锁的剩余有效时间）是否为null，

1. 1. 如果为null说明锁没有被占用。这样的话接着判断leasetime参数（释放锁的时间），如果leasetime为-1，说明锁不会自动过期，此时不启动**看门狗线程**。如果leasetime设置了一个具体的过期时间，就会启动看门狗线程，这个线程会在这个时间周期结束之前自动续期锁的有效期。
   2. 如果不为null，说明锁被其他线程占用了。这样的话会判断剩余等待时间是否>0，如果>0，则会订阅并等待释放锁的信号，当收到信号时，会判断等待时间是否超时，如果未超时，继续尝试获取锁；如果超时则结束。



## Redission可重入锁怎么实现的？

答：Redisson通过使用hash结构记录线程id（UUID拼接线程id）和重入次数来实现。每次获取锁时，持有计数会增加，而释放锁时，持有计数会减少。这样，即使同一个线程多次获取锁，只要它在每次释放锁时正确地减少持有计数，就可以保证锁的安全性和正确性。



比较是否是同一个线程时，你比较线程Id，多台机器的线程Id相等咋办？

答：可以用UUID改进。在线程开始时生成一个全局唯一标识符（UUID），并将其与线程关联（UUID+线程ID）。



redis哨兵选主机制，主从集群数据一致性，详细讲redis选主的投票机制？

答：Redis哨兵（Sentinel）的选主机制是Redis主从集群中实现高可用性的关键部分。当主节点（Master）发生故障时，哨兵会通过一系列步骤选举出一个新的主节点。以下是Redis哨兵选主机制的详细步骤：

1. **主观下线（Subjective Down）**：

- - 一个哨兵（Sentinel）如果发现主节点没有响应它的心跳检测（PING），会将主节点标记为主观下线。

1. **客观下线（Objective Down）**：

- - 为了确认主节点是否真的下线，这个哨兵会询问其他哨兵对这个主节点的连接情况。如果大多数哨兵都报告主节点不可达，那么主节点会被标记为客观下线。

1. **选举Sentinel Leader**：

- - 当确认主节点客观下线后，哨兵们会进入领导者选举过程。每个哨兵都会提出自己作为领导者的候选，并要求其他哨兵投票。投票过程遵循多数胜出的原则。

1. **投票机制**：

- - 哨兵在选举领导者时使用配置纪元（config epoch）来避免重复投票。每个哨兵每个纪元只能给一个候选人投票。候选人收到足够多的投票（超过哨兵数量的一半），并且票数大于或等于哨兵配置中的quorum值，它就会成为领导者（Sentinel Leader）。

1. **故障转移（Failover）**：

- - 一旦选出了Sentinel Leader，它将开始故障转移过程。领导者会从健康的从节点（Slave）中选择一个新的主节点，这个过程会考虑多个因素，如从节点的数据复制进度（replica offset）和优先级（slave-priority）。

1. **数据一致性**：

- - 在故障转移过程中，为了保持数据一致性，Sentinel Leader会指示新的主节点告知所有从节点更新它们的配置，将新的主节点作为它们的同步目标。

1. **通知系统**：

- - 故障转移完成后，Sentinel Leader会通过发布订阅机制通知所有的哨兵和客户端新的主节点信息。



## Redis的持久化

答：Redis支持 3 种持久化方式:

- RDB快照（Redis Database，RDB）
- 只追加文件（append-only file, AOF）
- RDB 和 AOF 的混合持久化(Redis 4.0 新增)

**快照持久化**是 Redis 默认采用的持久化方式。在 redis.conf 配置文件中默认有此下配置：

```bash
save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。

save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。
```

Redis 提供了两个命令来生成 RDB 快照文件：save : 同步保存操作，会阻塞 Redis 主线程；bgsave : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。

1. **优点**：

- - RDB文件紧凑，适合用于备份和灾难恢复。
  - 恢复速度快，因为它是数据的完整快照。

1. **缺点**：

- - 如果两次快照之间发生故障，这段时间内的数据可能会丢失。
  - 快照过程中如果Redis服务被打断，可能导致当前快照文件损坏。



**AOF 持久化**功能的实现可以简单分为 5 步：

1. **命令追加（append）**：所有的写命令会追加到 AOF 缓冲区中。
2. **文件写入（write）**：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用write函数（系统调用），write将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。
3. **文件同步（fsync）**：AOF 缓冲区根据对应的持久化方式（ fsync 策略）向硬盘做同步操作。这一步需要调用 fsync 函数（系统调用）， fsync 针对单个文件操作，对其进行强制硬盘同步，fsync 将阻塞直到写入磁盘完成后返回，保证了数据持久化。
4. **文件重写（rewrite）**：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。
5. **重启加载（load）**：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。

![img](https://cdn.nlark.com/yuque/0/2024/png/26317314/1713712969292-0d86bf14-cb08-4e52-bd62-9ea627d29462.png)

在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ fsync策略），它们分别是：

1. appendfsync always：主线程调用 write 执行写操作后，后台线程（ aof_fsync 线程）**立即**会调用 fsync 函数同步 AOF 文件（刷盘），fsync 完成后线程返回，这样会严重降低 Redis 的性能（write + fsync）。
2. appendfsync everysec：主线程调用 write 执行写操作后立即返回，由后台线程（ aof_fsync 线程）**每秒钟**调用 fsync 函数（系统调用）同步一次 AOF 文件（write+fsync，fsync间隔为 1 秒）
3. appendfsync no：主线程调用 write 执行写操作后立即返回，让**操作系统决定何时进行同步**，Linux 下一般为 30 秒一次（write但不fsync，fsync 的时机由操作系统决定）。

**优点**：

- - AOF提供了更好的持久性保证，可以通过配置达到几乎不会丢失数据的效果。
  - AOF文件可读，可以作为操作日志分析。

**缺点**：

- - AOF文件通常比RDB文件大。
  - 恢复速度可能比RDB慢，因为它需要重放所有的写操作命令。