## 类加载过程，双亲委派机制

【https://blog.csdn.net/qq_45912388/article/details/124615088】

答：类加载分为**动态加载**和**静态加载**。动态加载是从外存储器中加载类，一般类加载机制分析的也是动态加载。而静态加载本质上是从内存中创建类的实例对象，此时类已经被加载到内存中。

- 静态加载：`Dog dog1 = new Dog();`
- 动态加载：通过Class.forName()来加载类，然后调用类的newInstance()方法实例化对象，也就是反射

类加载的过程：主要分为三部分：加载—>连接（验证、准备、解析）—> 初始化

<img src="https://cdn.nlark.com/yuque/0/2024/png/26317314/1714646184195-2180b7ec-0b2f-46e8-96d6-44f4f754d991.png" alt="img" style="zoom:50%;" />

**加载**（重点），这个阶段通常也被称作“装载”，主要完成：

1. 通过“类全名”来获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口

**验证：****确保Class文件的字节流中包含的信息符合当前虚拟机的要求。**验证是确保Java程序安全性的重要步骤。通过验证，JVM可以防止加载恶意的、被篡改的或不符合规范的类。这有助于防止各种安全漏洞和攻击。

**准备：**正式为变量分配内存并设置初始值，这些内存都将在方法区中进行分配，这里的变量仅包括类标量不包括实例变量。

**解析：**虚拟机将常量池的符号引用替换为直接引用的过程。符号引用的意思是a = fun(1,2)，这种就是符号

**初始化****：**是执行类构造器()方法的过程 



JVM三种预定义类型类加载器

a. Bootstrap ClassLoader/启动类加载器

主要负责jdk_home/lib目录下的核心 api 或 -Xbootclasspath 选项指定的jar包装入工作.

b. Extension ClassLoader/扩展类加载器

主要负责jdk_home/lib/ext目录下的jar包或 -Djava.ext.dirs 指定目录下的jar包装入工作

c. System ClassLoader/系统类加载器

主要负责java -classpath/-Djava.class.path所指的目录下的类与jar包装入工作.

d. User Custom ClassLoader/用户自定义类加载器(java.lang.ClassLoader的子类)

在程序运行期间, 通过java.lang.ClassLoader的子类动态加载class文件, 体现java动态实时类装入特性



双亲委派加载

JVM在加载类时默认采用的是双亲委派机制， 先往上，让上层加载器去加载

**双亲委派模式：**当一个类需要加载时，判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。

<img src="https://cdn.nlark.com/yuque/0/2024/png/26317314/1714646733911-7b15fa85-37ea-491e-82d0-e5b808f18580.png" alt="img" style="zoom: 67%;" />

**沙箱安全机制（了解）**：本地代码被认为是安全的，而远程代码是不被信任的，因此就需要这样的一个机制去对这些远程代码进行访问授权。



HelloWorld类的加载过程

java HelloWorld命令的时候，JVM会将HelloWorld.class加载到内存中，并形成一个Class的对象HelloWorld.class。

其中的过程就是类加载过程：

1. 寻找jre目录，寻找jvm.dll（动态链接库），并初始化JVM；
2. 产生一个Bootstrap Loader（启动类加载器）；
3. Bootstrap Loader自动加载Extended Loader（标准扩展类加载器），并将其父Loader设为Bootstrap Loader。
4. Bootstrap Loader自动加载AppClass Loader（系统类加载器），并将其父Loader设为Extended Loader。
5. 最后由AppClass Loader加载HelloWorld类



## JVM结构

答：JVM可以分为5个部分，分别是：

（1）类加载器：加载字节码文件到内存

（2）运行时数据区：程序计数器、java栈、本地方法栈、堆、方法区；前三个是线程私有的，后两个是线程共享的

（3）执行引擎：对JVM指令进行解析，翻译成机器码，解析完成后提交到操作系统中

（4）本地库接口：供java调用的融合了不同开发语言的原生库

（5）本地方法库：Java本地方法的具体实现

在一个java进程中可能有很多正在运行的java线程，那么在每一个java线程中都会独立开辟本地方法栈，程序计算器，和Java栈的，而方法区和堆并不是独立开辟的，他们是线程共享的。垃圾回收在方法区和堆中执行。

运行时数据区：

1. **本地方法栈：**本地方法栈与java栈的作用和原理基本相同，都可以用来执行方法，不同观点在于java栈执行的是java方法，本地方法栈执行的是本地方法；本地方法：Java是基于应用层的高级编程语言，无法访问操作系统底层 信息，如：底层硬件设备等，这个时候就需要使用其它语言来完成功能了，比如C语言；
2. **java虚拟机栈：**java栈中存放的是多个栈帧，每个栈帧对应一个被调用的方法，主要包括局部变量表、操作数栈、动态链接、方法返回地址（方法出口）。每一个方法的执行，JVM都会创建一个栈帧，并将栈帧压入java栈，方法执行完毕，该栈帧出栈；

1. **程序计数器：**程序计数器占用的内存空间较小，是当前线程所执行的字节码行号指示器，通过改变这个计数器的值来选取下一条需要执行的字节码指令；多个线程之间的线程计算器相互独立，互不影响；
2. **方法区：**存储虚拟机加载的类信息、常量、静态变量，即时编译后的代码等数据。
3. **Java堆：**用来存放实例化对象，被所有线程共享，在虚拟机启动时创建；

<img src="https://cdn.nlark.com/yuque/0/2024/png/26317314/1714015004202-e29fbda4-ec7d-4dc1-af0b-df12571145ec.png" alt="img" style="zoom: 67%;" />



## JVM是如何管理年轻代和老年代的？

答：

1. 年轻代（Young Generation）：

- - 年轻代主要包括Eden区和两个Survivor区（S0和S1）。新创建的对象首先进入Eden区。
  - 当Eden区满时，JVM会触发一次Minor GC（复制算法），将存活的对象从Eden区复制到一个Survivor区（如S0）。
  - 随后，该Survivor区的对象在经过一定次数的GC后，会将存活的对象复制到另一个Survivor区（如S1），或者直接晋升到老年代。

1. 老年代（Old Generation）：

- - 老年代用于存放从年轻代晋升过来的对象，以及直接创建为大对象或长寿命的对象。
  - 老年代的空间通常比年轻代大，但GC发生的频率较低。
  - 当老年代空间不足时，JVM会触发一次Full GC（可以使用多种算法）（或者称为Major GC），对整个堆进行垃圾收集。

注意：Minor GC发生在年轻代，Full GC：发生在老年代，或者同时对整个堆进行垃圾收集



堆内存和栈内存的区别？为什么要分成堆、栈两部分呢？

答：

1. **堆内存（Heap）**：

- - 堆是JVM管理的最大的一块内存区域，用于存储对象实例和数组。几乎所有的对象实例都在堆上分配。
  - 堆是垃圾回收器（Garbage Collector，GC）管理的区域，因此程序员不需要（也不能）手动释放堆内存。
  - 堆内存的分配是动态的，垃圾回收器负责回收不再使用的对象，以释放内存。

1. **栈内存（Stack）**：

- - 栈用于存储线程的局部变量（如方法参数、局部变量和返回值等）以及临时数据。
  - 每个线程在创建时都会分配一个独立的栈空间，这块空间更小，但速度比堆内存快。
  - 栈内存的分配和回收由JVM自动管理，且随着方法的进入和退出自动进行。

1. **内存管理**：

- - 堆内存的内存管理是动态的，需要垃圾回收器周期性地进行回收。
  - 栈内存的内存管理是静态的，每个栈帧随着方法调用而入栈，方法结束而出栈。

1. **垃圾回收**：

- - 堆内存中的对象生命周期由垃圾回收器管理，存在内存泄漏和内存溢出的风险。
  - 栈内存中的对象生命周期与方法的调用相关，方法结束时，栈帧被销毁，内存自动被回收。

1. **内存大小**：

- - 堆内存的大小通常远大于栈内存的大小，因为堆内存需要存储整个应用程序的所有对象实例。
  - 栈内存的大小相对较小，且每个线程独立，其大小在线程创建时确定。

1. **分配效率**：

- - 堆内存的分配和回收速度相对较慢，因为涉及到垃圾回收算法的开销。
  - 栈内存的分配和回收速度非常快，因为分配和回收操作都是预先定义好的。

**为什么要分成堆和栈两部分：**因为存的是不同的东西，堆里面存储实例对象，数组等比较占内存的数据。而栈里面存的是多个栈帧，每个栈帧对应一个被调用的方法，包括方法的参数，返回值，局部变量等。堆里面数据线程共享，而栈里面数据每个线程独享。栈里面数据不能使用垃圾回收机制，当方法执行完了，对应的栈帧就会销毁。而堆里面的数据可以使用垃圾回收机制。因此，分成堆空间和栈空间，便于内存管理。【我的理解】





## 有哪些垃圾回收方法？

答：JVM垃圾回收的方法主要包括以下几种：

1. **引用计数法**：这是最早期的垃圾回收算法，每个对象有一个引用计数，当引用计数为0时，对象就会被回收。但这种方法不能解决循环引用的问题。
2. **标记-清除（Mark-Sweep）**：首先标记所有需要回收的对象，然后统一回收所有被标记的对象。这种方法可以解决循环引用的问题，但存在内存碎片化的问题。
3. **标记-整理（Mark-Compact）**：在标记-清除的基础上，增加了整理的过程，将存活的对象移动到内存的一端，从而解决内存碎片化的问题。
4. **复制算法（Copying）**：将内存分为两个区域，每次只使用一个区域，当这个区域满了之后，将存活的对象复制到另一个区域，然后一次性清理掉原来的区域。这种方法没有内存碎片问题，但内存使用率不高。
5. **分代收集（Generational Collection）**：基于对象生命周期的不同，将对象分为新生代和老年代，新生代的对象存活率低，适合使用复制算法；老年代的对象存活率高，适合使用标记-清除或标记-整理算法



## 常用的垃圾回收器有哪些？

答：Serial+Serial Old; ParNew+CMS; Parallel Scavenge+Parallel Old; G1。除了G1之外，其他的都要组合使用。

![img](https://cdn.nlark.com/yuque/0/2024/png/26317314/1717002805589-f1c0df6e-c7bb-4b2a-b592-716bc0b59868.png)

<img src="https://cdn.nlark.com/yuque/0/2024/png/26317314/1717002853421-3ae45f12-e063-4fd4-97a5-760c9e4ddf53.png" alt="img" style="zoom:67%;" />

1. Serial是一种单线程串行回收年轻代的垃圾回收器。-XX:+UseserialGc 。新生代、老年代都使用串行回收器。年轻代使用复制算法，老年代使用标记-整理算法。优点是单CPU下吞吐量出色，但多CPU时不如其他垃圾回收器，适合硬件配置资源有限的场景。垃圾回收时会中断用户线程。
2. PS+PO是JDK8默认的垃圾回收器，多线程并行回收关注的是系统的吞吐量。具备自动调整堆内存大小的特点。年轻代使用复制算法，老年代使用标记-整理算法。因为多线程回收，所以吞吐量大。缺点是不能保证单次的停顿时间。适用于后台任务，不需要与用户交互，并且容易产生大量的对象比如:大数据的处理，大文件导出。所谓停顿时间是指：垃圾回收时会中断用户线程，暂停的这个时间。

<img src="https://cdn.nlark.com/yuque/0/2024/png/26317314/1717003750090-21717d66-7a0b-4c67-a2c5-8a3d107434ce.png" alt="img" style="zoom:67%;" />

1. ParNew垃圾回收器本质上是对Serial在多CPU下优化，使用多线程进行垃圾回收XX:+UseParNewGc新生代使用ParNew回收器，老年代使用串行回收器。年轻代使用复制算法。吞吐量和停顿时间不如G1，所以在JDK9之后不建议使用。适用场景，JDK8及之前的版本中，与CMS老年代垃圾回收器搭配使用。
2. CMS垃圾回收器（**Concurrent Mark Sweep**）关注的是系统的暂停时间。允许用户线程和垃圾回收线程在某些步骤中同时执行，减少了用户线程的等待时间。参数:-XX:+UseConcMarkSweepGC。老年代使用标记-清除算法。优点是垃圾回收出现的停顿时间较短，用户体验好。缺点是内存碎片，浮动垃圾等问题。适用场景：大型的互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等。JDK9之后已被淘汰。所谓“浮动垃圾”是指CMS运行的时候，用户线程也在运行，会产生新的垃圾，这个垃圾得等下一次才能被回收。

<img src="https://cdn.nlark.com/yuque/0/2024/png/26317314/1717004244045-19668c10-f207-4935-90b9-f9788b0593c5.png" alt="img" style="zoom: 80%;" />

![img](https://cdn.nlark.com/yuque/0/2024/png/26317314/1717004858040-255c0c7a-d10f-4d0d-a185-2ebe0b630150.png)

1. G1垃圾回收器。参数1: -XX:+UseG1GC 打开G1的开关，JDK9之后默认不需要打开	参数2:-XX:MaxGCPauseMilis=毫秒值最大暂停的时间。年轻代和老年代都使用复制算法（老年代是标记-复制-整理）。优点是延迟可控，不会产生内存碎片。

<img src="https://cdn.nlark.com/yuque/0/2024/png/26317314/1717005189303-7c6460ee-d30d-4f30-943f-3a44a79ec6c2.png" alt="img" style="zoom:80%;" />

1. 如果需要更低的延迟就需要Shenandoah或者ZGC了。Shenandoah 是由Red Hat开发的一款低延迟的垃圾收集器，Shenandoah 并发执行大部分 GC 工作，包括并发的整理，堆大小对STW的时间基本没有影响，STW10毫秒以内。ZGC 是一种可扩展的低延迟垃圾回收器。ZGC在垃圾回收过程中，STW的时间不会超过1毫秒，适合需要低延迟的应用。支持几百兆到16TB 的堆大小，堆大小对STW的时间基本没有影响。它们虽然停顿时间短，但整个垃圾回收时间可能比较长。
2. 总结：**JDK8及之前：**ParNew+CMS(关注暂停时间)、Parallel Scavenge + Parallel Old (关注吞吐量)、 G1(JDK8之前不建议)。JDK9之后：G1(默认)如果对低延迟有较高的要求，可以使用Shenandoah或者ZGC。

<img src="https://cdn.nlark.com/yuque/0/2024/png/26317314/1717005682463-5c3be371-53c1-4160-86e7-c6043995cfbb.png" alt="img" style="zoom: 50%;" />