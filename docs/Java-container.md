## 容器关系图

![img](https://cdn.nlark.com/yuque/0/2024/png/26317314/1716367821587-f5ea0b2d-42e2-462d-aa3e-477d124b44a4.png)

## HashMap,HashTable和ConcurrentHashMap

1. HashMap不是线程安全的，Hashtable是线程安全的，在 HashTable 中，基本上所有的方法都加上了 synchronized关键字，所以锁很重；
2. HashMap的key和value可以为null，而Hashtable和ConcurrentHashMap都不能。例如，如果尝试在HashTable中插入null键或null值，将会抛出NullPointerException；

![img](https://cdn.nlark.com/yuque/0/2024/png/26317314/1717007283215-8b48c39a-1d08-4fbb-9032-53156ee796f7.png)

1. 如果需要在多线程环境中使用Map，可以使用ConcurrentHashMap。



ConcurrentHashMap

答：（JDK17里面源码相当长，6382行）只找到12处synchronized，且均作用于代码块。ConcurrentHashMap在JDK1.7和1.8有不同的实现。

1. JDK1.7使用分段锁实现。底层数据结构：Segments数组+HashEntry数组+链表，采用分段锁保证安全性。即整个ConcurrentHashMap 分成了多个Segments段，每个Segment又存储多个HashEntry元素，每个HashEntry都是链表。Segment继承了ReentrantLock锁，相当于把所有数据分成了一个一个的Segment分段，当线程访问一个段时会加互斥锁，保证当前段的线程安全，其他段则不受影响，实现多线程并发。缺点：同一个Segment段不能多线程并发。
2. JDK1.8 和HashMap一致了，底层采用数组+链表 / 红黑树 +CAS+ Synchronized。

源码解读【https://blog.csdn.net/mrluo735/article/details/134281987】

待完善……

```java
# 1. 扩展了..，实现了..
public class ConcurrentHashMap<K,V> extends AbstractMap<K,V>
implements ConcurrentMap<K,V>, Serializable

# 2. 一些参数
private static final int MAXIMUM_CAPACITY = 1 << 30;
private static final int DEFAULT_CAPACITY = 16;
private static final float LOAD_FACTOR = 0.75f;
static final int TREEIFY_THRESHOLD = 8;
static final int UNTREEIFY_THRESHOLD = 6;//退化
```





## HashMap及其扩容原理(16, 0.75, 1倍)，以及put，get方法实现流程

【https://blog.csdn.net/bandaoyu/article/details/108082194】（这个博客讲的挺好）

答：HashMap基于Map接口实现，元素以键值对的方式存储，并且允许使用null 键和null值，因为key不允许重复，因此只能有一个键为null，另外HashMap不能保证放入元素的顺序，它是无序的。HashMap是线程不安全的。JDK 1.8里面，HashMap采用数组+链表+红黑树实现。初始容量默认值为16，负载因子默认值为0.75。HashMap是线程不安全的，原因就在于它的扩容机制。

扩容原理：当hashmap中的元素个数超过数组大小loadFactor（负载因子）时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16×0.75=12的时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75×1000 < 1000, 也就是说为了让0.75 × size > 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&的问题，也避免了resize的问题

put()方法：

1. **键非空检查**：确保键不为空，或者如果键为空，则检查是否已存在一个键为 null 的条目。
2. **计算哈希值**：对键调用 hashCode() 方法获取哈希值。
3. **定位桶索引**：根据哈希值计算出在散列表中的索引位置。比如可以使用模运算，但实际使用的按位与，index =  HashCode（Key） &  （Length - 1）
4. **处理已有值**：

- - 如果桶为空，直接插入新的键值对。
  - 如果桶中存在该键，则替换旧值并返回旧值。

1. **解决冲突**：

- - 如果桶中存在其他键，则在链表或红黑树中添加新键值对。（哈希值（索引值）一样的话，再比较key的内容是否一样）

1. **扩容：**哈希冲突时，如果链表<8，直接插入；如果链表长度>8并且数组容量<64，就进行扩容；如果>8并且数组容量>64，转成红黑树。





## **JDK 1.7和1.8中，hashmap有什么不同**

答：在JDK 1.7和1.8中，HashMap的主要区别体现在**数据结构、数据插入方式、扩容方式**上。

1. 数据结构：

- - JDK 1.7：使用的是数组+单链表的数据结构。当哈希冲突时，通过链表解决。
  - JDK 1.8及以后：使用的是数组+链表+红黑树的数据结构。当链表的长度达到一定的阈值（默认为8）时，链表会转换为红黑树，以提高查询效率。

1. 数据插入方式：

- - JDK 1.7：在解决哈希冲突时，使用的是头插法将新元素插入到链表的头部。但这种方法在并发场景下可能会导致循环链表，进而引发问题。
  - JDK 1.8：改用尾插法将新元素插入到链表的尾部，从而避免了头插法可能导致的循环链表问题。

1. 扩容方式：

- - JDK 1.7：在扩容时，需要重新计算哈希值，并将原数组的数据复制到新的数组中。这个过程可能会涉及大量的数据移动，效率较低。
  - JDK 1.8：引入了新的扩容算法，通过原数组中的元素进行哈希运算后，根据运算结果决定元素在新数组中的位置。这种方式减少了数据的移动，提高了扩容的效率。



## **hashmap和hashset的区别？**

答：hashset源码用了hashmap，但只用了key的部分，而value是一个固定值。

```java
//源码添加元素
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}

//而PRESENT是一个常量
private static final Object PRESENT = new Object();
```

1.实现的接口不同

HashSet实现的是Set接口，HashMap实现的是Map接口

2.存储内容不同

HashSet存储的是对象，HashMap存储的是键值对

3.添加元素的方法不同

HashSet是通过add()方法添加元素

HashMap是通过put()方法添加元素



## 重写equals时，hashcode要重写吗？

答：需要。Java集合框架的**规范**明确要求，如果两个对象根据equals(Object)方法是相等的，那么它们的hashCode()方法必须返回相同的整数结果。如果两个对象的 hashCode（）相同， 但equals（）不一定相同。hashCode()返回该对象的哈希码值；equals()返回两个对象是否相等。如果两个对象equals()相等，那么两个对象的hashCode()方法返回的结果也必然相等。如果重写equals()方法，必须重写hashCode()方法，以保证equals方法相等时两个对象hashcode返回相同的值。



## ArrayList的底层实现(10, 1.5)

答：**ArrayList**底层基于数组实现，查找快，增删慢。默认初始容量为10，只有在调用add方法添加第一个元素时才会在底层创建默认长度为10的数组。当元素插满，会进行**扩容**，每次扩容到之前的1.5倍（oldCapacity + (oldCapacity >> 1，二进制右移即除二，左移乘二），如果扩容1.5倍之后容量还不够，则将所需要的最小容量minCapacity赋给数组新的容量值newCapacity；扩容之后通过数组的拷贝（使用Arrays.copyOf）来确保元素的准确性。ArrayList是线程不安全的。如果要线程安全，可以：

1. 使用**Vector**，但vector使用Synchronized关键字，直接锁住整个方法,并发效率低。
2. 也可以使用集合的工具类Collections提供的synchronizedList方法将线程不安全的集合类变为安全的。
3. 在大量并发情况下使用**CopyOnWriteArrayList**提高集合的效率和安全，它使用Lock锁相较于Synchronized关键字更为灵活、效率更高；使用volatile保证值被修改后，其它线程能够立马感知到最新值。且CopyOnWriteArrayList中只有写操作加了lock锁，而读操作(get方法)未加锁，从而提高读取效率（而synchronizedList和Vector中的get方法均加了synchronized关键字）



## 红黑树，B+树，平衡二叉树

解释一下什么是红黑树？有什么应用场景？平衡二叉树有什么缺点呢？

答：首先说一下二叉搜索树，它满足左子树上所有结点的值均小于或等于它的根结点的值。右子树上所有结点的值均大于或等于它的根结点的值。左、右子树也分别为二叉排序树。

**红黑树**是一种自平衡的二叉搜索树，其中每个节点都有一个颜色属性，可以是红色或黑色。红黑树的名称来源于这两种颜色的使用。它满足以下性质：

1. **每个节点要么是红色，要么是黑色。**
2. **根节点是黑色的。**
3. **所有叶子节点（NIL节点，空节点）都是黑色的。**
4. **如果一个节点是红色的，则它的两个子节点都是黑色的（从每个叶子到根的所有简单路径都不含两个连续的红色节点）。**
5. **从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（即具有相同的黑色高度）。**
6. **红黑树从根节点到叶子节点的最长路径不会超过最短路径的两倍**

红黑树的应用场景包括：

1. **数据结构：**TreeSet、TreeMap、HashMap（JDK8）
2. **索引结构**：在数据库索引或其他需要快速查找和排序的数据结构中，红黑树也得到应用。

**平衡二叉树**是一种特殊的二叉搜索树，其中每个节点的左子树和右子树的高度差至多为1。尽管平衡二叉树可以保证O(log n)的查找时间复杂度，但它也有一些缺点：

1. **插入和删除操作可能较慢**：平衡二叉树在插入和删除节点后需要重新平衡，这可能涉及复杂的旋转操作，导致性能下降。
2. **空间效率较低**：平衡二叉树为了保持平衡，可能在树的某些部分留有较多的空位，导致空间利用不是最优化。
3. **范围查询效率不高**：平衡二叉树不适合执行范围查询，因为它没有排序的链表结构来快速访问一个范围内的元素。
4. **实现复杂**：相比于非平衡二叉搜索树，平衡二叉树的实现更为复杂，需要更多的代码来处理旋转和颜色更新等操作。
5. **可能不适合某些数据特性**：对于某些具有特定分布特性的数据，平衡二叉树可能不如其他数据结构（如B树或B+树）高效。

红黑树作为一种特殊的平衡二叉树，通过引入颜色属性和简单的规则来保持树的大致平衡，从而确保了最坏情况下的查找、插入和删除操作都能在O(log n)时间内完成。这使得红黑树在需要频繁插入和删除的场景下非常适用。



## 红黑树和平衡二叉树的区别？

答：平衡二叉树（AVL）任意结点的左、右子树的高度差的绝对值不超过1。在AVL树的平衡标准上进一步放宽条件，就引入了红黑树。红黑树从根节点到叶结点的最大路径不大于最短路径的2倍；根结点、叶结点都是黑色；不存在两个相邻红结点；对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同。红黑树能够以O(log2(N))的时间复杂度进行搜索、插入、删除操作。此外,任何不平衡都会在3次旋转之内解决。这一点是AVL所不具备的。



## B树和B+树有什么区别？

答：B树和B+树都是平衡的多路搜索树，它们在数据库系统和文件系统的索引结构中非常常见。

什么是B树：一种平衡多路搜索树，树的阶定义为树中所有孩子结点个数的最大值。例如下图是一个4阶B树。B 树中的每个节点由两部分组成：**关键字（可以理解为数据）**与**指向孩子节点的指针。**B树多用于做文件系统的索引。

![img](https://cdn.nlark.com/yuque/0/2024/png/26317314/1716305943022-5a5a4c6d-f55b-46c1-a5cf-30219479556d.png)

B树满足如下条件：

1. 非叶节点至少有两棵子树
2. 对于一个M阶B树，除根节点以外的所有非叶节点至少有M/2(注意向上取整)棵子树，至多有M个子树；
3. 所有的叶子节点都位于同一层。



B树和B+树的区别：

1. **定义**：

- - B树：每个节点可以有多个关键字和多个子节点，关键字分布在所有子节点中。
  - B+树：每个内部节点的关键字只充当路标，不保存数据，所有的数据都保存在叶子节点中。

1. **内部节点存储**：

- - B树的内部节点存储数据。
  - B+树的内部节点不存储数据，只存储索引键和子节点指针。

1. **叶子节点**：

- - B树的叶子节点不必须相互连接。
  - B+树的叶子节点通过指针相互连接，形成有序链表，便于范围查询。

1. **查询性能**：

- - B树的查询效率可能不如B+树稳定，因为查询可能在内部节点结束，而不必达到叶子节点。
  - B+树的所有查询都会走到叶子节点，这使得B+树在执行范围查询时更加高效，因为可以通过叶子节点的链表顺序访问。

1. **磁盘I/O**：

- - B+树由于其结构特点，查询任何数据都会访问到叶子节点，故磁盘I/O次数比B树少，更适合大量数据的读写操作。

1. **更新和删除操作**：

- - B+树由于其结构特点，进行插入和删除操作时，需要的树内节点移动和重新平衡的可能性更小，这使得B+树在更新和删除操作上可能比B树更高效。

1. **应用场景**：

- - B树适合于查询和更新操作比较均匀的场景。
  - B+树由于其叶子节点形成有序链表，更适合执行范围查询和用作数据库索引和文件系统的索引结构。

1. **空间利用**：

- - B+树的内部节点可以存储更多的键值，空间效率更高。

总的来说，B+树相对于B树，在数据库和文件系统索引中更常用，因为它的结构更适合这些场景下频繁进行的范围查询和顺序访问操作。然而，选择B树还是B+树，还需根据具体的应用需求和操作模式来决定。